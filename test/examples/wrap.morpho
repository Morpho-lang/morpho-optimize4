

import optimize4 
import meshtools 
import plot 

// Make a class to manufacture axis aligned ellipsoids.
// To create one, call Ellipsoid(origin, principalradii)
class Ellipsoid {
  init(x, r) {
    self.origin = x
    self.principalradii = r
  }

  // Returns a level set function for this Ellipsoid
  levelset() {
    fn phi (x,y,z) {
      var x0 = self.origin, rr = self.principalradii
      return ((x-x0[0])/rr[0])^2 + ((y-x0[1])/rr[1])^2 + ((z-x0[2])/rr[2])^2 - 1
    }

    return phi
  }

  // Returns the a function that returns the gradient
  // of the level set function for this Ellipsoid
  gradient() {
    fn dphi (x,y,z) {
      var x0 = self.origin, rr = self.principalradii
      return Matrix([2*(x-x0[0])/rr[0]^2,
                     2*(y-x0[1])/rr[1]^2,
                     2*(z-x0[2])/rr[2]^2])
    }

    return dphi
  }
}

// Now for the wrap example
class WrapExample {
  init(L=2, kreg=0.1) {
    self.L = L 
    self.kreg = kreg
    self.mesh = nil 
    self.problem = nil 
  }

  initialMesh() { 
    var L = 2

    var cube = [[-L, -L, -L], [-L, -L, L], [-L, L, -L],
                [-L, L, L], [L, -L, -L], [L, -L, L],
                [L, L, -L], [L, L, L]]

    var faces = [[7, 3, 1, 5], [7, 5, 4, 6], [7, 6, 2, 3], [3, 2, 0, 1], [0, 2, 6,
    4], [1, 0, 4, 5]]

    self.mesh=PolyhedronMesh(cube, faces)
    self.mesh.addgrade(1)
    refine()
  }

  initialField() { }

  buildProblem() { 
    // Now use this to manufacture some Ellipsoids
    var ell1 = Ellipsoid([0,1/2,0],[1/2,1/2,1])
    var ell2 = Ellipsoid([0,-1/2,0],[1,1/2,1/2])

    self.problem = OptimizationProblem(self.mesh)

    // We want to minimize the area
    var la = Area()
    self.problem.addenergy(la)

    // Subject to level set constraints
    var ls1 = ScalarPotential( ell1.levelset(), ell1.gradient() )
    var ls2 = ScalarPotential( ell2.levelset(), ell2.gradient() )
    self.problem.addlocalconstraint(ls1, onesided=true)
    self.problem.addlocalconstraint(ls2, onesided=true)

    var leq = EquiElement()
    self.problem.addenergy(leq, prefactor=self.kreg)
  }

  buildAdapter() { 
    return ProblemAdapter(self.problem, self.mesh)
  }

  build() { // Setup the problem and return an Adapter
    self.initialMesh()
    self.initialField()
    self.buildProblem()
    return self.buildAdapter()
  }

  refine() {
    var mr=MeshRefiner([self.mesh])
    var refmap = mr.refine()
    for (el in [self.problem]) if (el) el.update(refmap)
    self.mesh = refmap[self.mesh]

    print self.mesh 
    equiangulate(self.mesh)
  }

  visualize() { 
    return plotmesh(self.mesh, grade=2)
  }
}
